From 0e711d71bd153aa8e6e4c2e6a7ca705139adc625 Mon Sep 17 00:00:00 2001
From: Anup Patel <apatel@ventanamicro.com>
Date: Mon, 21 Aug 2023 10:20:29 +0530
Subject: [PATCH] lib: sbi: Add RPMI proxy (RPXY) framework

We introduce RPMI proxy framework which allows platform specific
code or driver to register RPMI proxy service groups. These RPMI
proxy service groups will allow supervisor software to send RPMI
messages using the SBI RPMI Proxy extension.

Signed-off-by: Anup Patel <apatel@ventanamicro.com>
---
 include/sbi/sbi_platform.h |  17 +++
 include/sbi/sbi_rpxy.h     |  87 ++++++++++++++
 lib/sbi/objects.mk         |   1 +
 lib/sbi/sbi_init.c         |   7 ++
 lib/sbi/sbi_rpxy.c         | 228 +++++++++++++++++++++++++++++++++++++
 5 files changed, 340 insertions(+)
 create mode 100644 include/sbi/sbi_rpxy.h
 create mode 100644 lib/sbi/sbi_rpxy.c

diff --git a/include/sbi/sbi_platform.h b/include/sbi/sbi_platform.h
index 2fb33e16..bc774ff9 100644
--- a/include/sbi/sbi_platform.h
+++ b/include/sbi/sbi_platform.h
@@ -133,6 +133,9 @@ struct sbi_platform_operations {
 	/** Exit platform timer for current HART */
 	void (*timer_exit)(void);
 
+	/** Initialize the platform RPMI proxy service groups */
+	int (*rpxy_init)(void);
+
 	/** Check if SBI vendor extension is implemented or not */
 	bool (*vendor_ext_check)(void);
 	/** platform specific SBI extension implementation provider */
@@ -635,6 +638,20 @@ static inline void sbi_platform_timer_exit(const struct sbi_platform *plat)
 		sbi_platform_ops(plat)->timer_exit();
 }
 
+/**
+ * Initialize the platform RPMI proxy service groups
+ *
+ * @param plat pointer to struct sbi_platform
+ *
+ * @return 0 on success and negative error code on failure
+ */
+static inline int sbi_platform_rpxy_init(const struct sbi_platform *plat)
+{
+	if (plat && sbi_platform_ops(plat)->rpxy_init)
+		return sbi_platform_ops(plat)->rpxy_init();
+	return 0;
+}
+
 /**
  * Check if SBI vendor extension is implemented or not.
  *
diff --git a/include/sbi/sbi_rpxy.h b/include/sbi/sbi_rpxy.h
new file mode 100644
index 00000000..f52e8021
--- /dev/null
+++ b/include/sbi/sbi_rpxy.h
@@ -0,0 +1,87 @@
+/*
+ * SPDX-License-Identifier: BSD-2-Clause
+ *
+ * Copyright (c) 2023 Ventana Micro Systems Inc.
+ *
+ * Authors:
+ *   Anup Patel <apatel@ventanamicro.com>
+ */
+
+#ifndef __SBI_RPXY_H__
+#define __SBI_RPXY_H__
+
+#include <sbi/sbi_list.h>
+
+struct sbi_scratch;
+
+/** A RPMI proxy service accessible through SBI interface */
+struct sbi_rpxy_service {
+	u8 id;
+	u32 min_tx_len;
+	u32 max_tx_len;
+	u32 min_rx_len;
+	u32 max_rx_len;
+};
+
+/** A RPMI proxy service group accessible through SBI interface */
+struct sbi_rpxy_service_group {
+	/** List head to a set of service groups */
+	struct sbi_dlist head;
+
+	/** Details identifying this service group */
+	u32 transport_id;
+	u32 service_group_id;
+	unsigned long max_message_data_len;
+
+	/** Array of supported services */
+	int num_services;
+	struct sbi_rpxy_service *services;
+
+	/**
+	 * Send a normal/posted message for this service group
+	 * NOTE: For posted message, ack_len == NULL
+	 */
+	int (*send_message)(struct sbi_rpxy_service_group *grp,
+			    struct sbi_rpxy_service *srv,
+			    void *tx, u32 tx_len,
+			    void *rx, u32 rx_len,
+			    unsigned long *ack_len);
+
+	/** Get notification events for this service group */
+	int (*get_notification_events)(struct sbi_rpxy_service_group *grp,
+				       void *output_data,
+				       u32 output_data_len,
+				       unsigned long *events_len);
+};
+
+/** Check if some RPMI proxy service group is available */
+bool sbi_rpxy_service_group_available(void);
+
+/** Probe RPMI proxy service group */
+int sbi_rpxy_probe(u32 transport_id, u32 service_group_id,
+		   unsigned long *out_max_data_len);
+
+/** Set RPMI proxy shared memory on the calling HART */
+int sbi_rpxy_set_shmem(unsigned long shmem_size,
+		       unsigned long shmem_phys_lo,
+		       unsigned long shmem_phys_hi,
+		       unsigned long flags);
+
+/** Send a normal/posted RPMI proxy message */
+int sbi_rpxy_send_message(u32 transport_id,
+			  u32 service_group_id,
+			  u8 service_id,
+			  unsigned long message_data_len,
+			  unsigned long *ack_data_len);
+
+/** Get RPMI proxy notification events */
+int sbi_rpxy_get_notification_events(u32 transport_id, u32 service_group_id,
+				     unsigned long *events_len);
+
+/** Register a RPMI proxy service group */
+int sbi_rpxy_register_service_group(struct sbi_rpxy_service_group *grp);
+
+/** Initialize RPMI proxy subsystem */
+int sbi_rpxy_init(struct sbi_scratch *scratch);
+
+#endif
diff --git a/lib/sbi/objects.mk b/lib/sbi/objects.mk
index 0a50e95c..20115448 100644
--- a/lib/sbi/objects.mk
+++ b/lib/sbi/objects.mk
@@ -74,6 +74,7 @@ libsbi-objs-y += sbi_misaligned_ldst.o
 libsbi-objs-y += sbi_platform.o
 libsbi-objs-y += sbi_pmu.o
 libsbi-objs-y += sbi_dbtr.o
+libsbi-objs-y += sbi_rpxy.o
 libsbi-objs-y += sbi_scratch.o
 libsbi-objs-y += sbi_string.o
 libsbi-objs-y += sbi_system.o
diff --git a/lib/sbi/sbi_init.c b/lib/sbi/sbi_init.c
index 804b01cd..e210b720 100644
--- a/lib/sbi/sbi_init.c
+++ b/lib/sbi/sbi_init.c
@@ -24,6 +24,7 @@
 #include <sbi/sbi_platform.h>
 #include <sbi/sbi_pmu.h>
 #include <sbi/sbi_dbtr.h>
+#include <sbi/sbi_rpxy.h>
 #include <sbi/sbi_system.h>
 #include <sbi/sbi_string.h>
 #include <sbi/sbi_timer.h>
@@ -356,6 +357,12 @@ static void __noreturn init_coldboot(struct sbi_scratch *scratch, u32 hartid)
 		sbi_hart_hang();
 	}
 
+	rc = sbi_rpxy_init(scratch);
+	if (rc) {
+		sbi_printf("%s: rpxy init failed (error %d)\n", __func__, rc);
+		sbi_hart_hang();
+	}
+
 	/*
 	 * Note: Finalize domains after HSM initialization so that we
 	 * can startup non-root domains.
diff --git a/lib/sbi/sbi_rpxy.c b/lib/sbi/sbi_rpxy.c
new file mode 100644
index 00000000..c25e0a16
--- /dev/null
+++ b/lib/sbi/sbi_rpxy.c
@@ -0,0 +1,228 @@
+/*
+ * SPDX-License-Identifier: BSD-2-Clause
+ *
+ * Copyright (c) 2023 Ventana Micro Systems Inc.
+ *
+ * Authors:
+ *   Anup Patel <apatel@ventanamicro.com>
+ */
+
+#include <sbi/riscv_asm.h>
+#include <sbi/sbi_domain.h>
+#include <sbi/sbi_error.h>
+#include <sbi/sbi_hart.h>
+#include <sbi/sbi_platform.h>
+#include <sbi/sbi_rpxy.h>
+#include <sbi/sbi_scratch.h>
+
+struct rpxy_state {
+	unsigned long shmem_size;
+	unsigned long shmem_addr;
+};
+
+/** Offset of pointer to RPXY state in scratch space */
+static unsigned long rpxy_state_offset;
+
+/** List of RPMI proxy service groups */
+static SBI_LIST_HEAD(rpxy_group_list);
+
+static struct sbi_rpxy_service *rpxy_find_service(
+					struct sbi_rpxy_service_group *grp,
+					u8 service_id)
+{
+	int i;
+
+	for (i = 0; i < grp->num_services; i++)
+		if (grp->services[i].id == service_id)
+			return &grp->services[i];
+
+	return NULL;
+}
+
+static struct sbi_rpxy_service_group *rpxy_find_group(u32 transport_id,
+						      u32 service_group_id)
+{
+	struct sbi_rpxy_service_group *grp;
+
+	sbi_list_for_each_entry(grp, &rpxy_group_list, head)
+		if (grp->transport_id == transport_id &&
+		    grp->service_group_id == service_group_id)
+		    return grp;
+
+	return NULL;
+}
+
+bool sbi_rpxy_service_group_available(void)
+{
+	return sbi_list_empty(&rpxy_group_list) ? false : true;
+}
+
+int sbi_rpxy_probe(u32 transport_id, u32 service_group_id,
+		   unsigned long *out_max_data_len)
+{
+	int rc = SBI_ENOTSUPP;
+	struct sbi_rpxy_service_group *grp;
+
+	*out_max_data_len = 0;
+	grp = rpxy_find_group(transport_id, service_group_id);
+	if (grp) {
+		*out_max_data_len = grp->max_message_data_len;
+		rc = 0;
+	}
+
+	return rc;
+}
+
+int sbi_rpxy_set_shmem(unsigned long shmem_size,
+		       unsigned long shmem_phys_lo,
+		       unsigned long shmem_phys_hi,
+		       unsigned long flags)
+{
+	struct rpxy_state *rs =
+		sbi_scratch_thishart_offset_ptr(rpxy_state_offset);
+
+	if (shmem_phys_lo == -1UL && shmem_phys_hi == -1UL) {
+		rs->shmem_size = 0;
+		rs->shmem_addr = 0;
+		return 0;
+	}
+
+	if (flags || !shmem_size ||
+	    (shmem_size & ~PAGE_MASK) ||
+	    (shmem_phys_lo & ~PAGE_MASK))
+		return SBI_EINVAL;
+	if (shmem_phys_hi ||
+	    !sbi_domain_check_addr_range(sbi_domain_thishart_ptr(),
+					 shmem_phys_lo, shmem_size, PRV_S,
+					 SBI_DOMAIN_READ|SBI_DOMAIN_WRITE))
+		return SBI_EINVALID_ADDR;
+
+	rs->shmem_size = shmem_size;
+	rs->shmem_addr = shmem_phys_lo;
+	return 0;
+}
+
+int sbi_rpxy_send_message(u32 transport_id,
+			  u32 service_group_id,
+			  u8 service_id,
+			  unsigned long message_data_len,
+			  unsigned long *ack_data_len)
+{
+	int rc;
+	u32 tx_len = 0, rx_len = 0;
+	void *tx = NULL, *rx = NULL;
+	struct sbi_rpxy_service *srv = NULL;
+	struct sbi_rpxy_service_group *grp;
+	struct rpxy_state *rs =
+		sbi_scratch_thishart_offset_ptr(rpxy_state_offset);
+
+	if (!rs->shmem_size)
+		return SBI_ENO_SHMEM;
+
+	grp = rpxy_find_group(transport_id, service_group_id);
+	if (grp)
+		srv = rpxy_find_service(grp, service_id);
+	if (!srv)
+		return SBI_ENOTSUPP;
+
+	tx_len = message_data_len;
+	if (tx_len > rs->shmem_size || tx_len > grp->max_message_data_len)
+		return SBI_EINVAL;
+	if (tx_len < srv->min_tx_len || srv->max_tx_len < tx_len)
+		return SBI_EFAIL;
+
+	sbi_hart_map_saddr(rs->shmem_addr, rs->shmem_size);
+
+	tx = (void *)rs->shmem_addr;
+	if (ack_data_len) {
+		rx = (void *)rs->shmem_addr;
+		if (srv->min_rx_len == srv->max_rx_len)
+			rx_len = srv->min_rx_len;
+		else if (srv->max_rx_len < grp->max_message_data_len)
+			rx_len = srv->max_rx_len;
+		else
+			rx_len = grp->max_message_data_len;
+	}
+
+	rc = grp->send_message(grp, srv, tx, tx_len, rx, rx_len, ack_data_len);
+	sbi_hart_unmap_saddr();
+	if (rc)
+		return rc;
+
+	if (ack_data_len &&
+	    (*ack_data_len > rs->shmem_size ||
+	     *ack_data_len > grp->max_message_data_len))
+		return SBI_EFAIL;
+
+	return 0;
+}
+
+int sbi_rpxy_get_notification_events(u32 transport_id, u32 service_group_id,
+				     unsigned long *events_len)
+{
+	int rc;
+	struct sbi_rpxy_service_group *grp;
+	struct rpxy_state *rs =
+		sbi_scratch_thishart_offset_ptr(rpxy_state_offset);
+
+	if (!rs->shmem_size)
+		return SBI_ENO_SHMEM;
+
+	grp = rpxy_find_group(transport_id, service_group_id);
+	if (!grp)
+		return SBI_ENOTSUPP;
+
+	if (!grp->get_notification_events || !events_len)
+		return SBI_EFAIL;
+
+	sbi_hart_map_saddr(rs->shmem_addr, rs->shmem_size);
+	rc = grp->get_notification_events(grp, (void *)rs->shmem_addr,
+					  rs->shmem_size,
+					  events_len);
+	sbi_hart_unmap_saddr();
+	if (rc)
+		return rc;
+
+	if (*events_len > rs->shmem_size)
+		return SBI_EFAIL;
+
+	return 0;
+}
+
+int sbi_rpxy_register_service_group(struct sbi_rpxy_service_group *grp)
+{
+	int i;
+	struct sbi_rpxy_service *srv;
+
+	if (!grp ||
+	    !grp->max_message_data_len ||
+	    !grp->num_services || !grp->services ||
+	    !grp->send_message)
+		return SBI_EINVAL;
+	for (i = 0; i < grp->num_services; i++) {
+		srv = &grp->services[i];
+		if (!srv->id ||
+		    (srv->min_tx_len > srv->max_tx_len) ||
+		    (srv->min_tx_len > grp->max_message_data_len) ||
+		    (srv->min_rx_len > srv->max_rx_len) ||
+		    (srv->min_rx_len > grp->max_message_data_len))
+			return SBI_EINVAL;
+	}
+
+	if (rpxy_find_group(grp->transport_id, grp->service_group_id))
+		return SBI_EALREADY;
+
+	SBI_INIT_LIST_HEAD(&grp->head);
+	sbi_list_add_tail(&grp->head, &rpxy_group_list);
+
+	return 0;
+}
+
+int sbi_rpxy_init(struct sbi_scratch *scratch)
+{
+	rpxy_state_offset = sbi_scratch_alloc_type_offset(struct rpxy_state);
+	if (!rpxy_state_offset)
+		return SBI_ENOMEM;
+
+	return sbi_platform_rpxy_init(sbi_platform_ptr(scratch));
+}
